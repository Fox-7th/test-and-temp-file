# LeetCode 热题清单（去重版）

以下内容按你提供的分类与顺序整理，重复题目已在首次出现处保留，后续分类中不再重复。每题包含简要思路与可运行 Python 解法（LeetCode 习惯的 `Solution` 形式）。

## 哈希 / 双指针 / 数组

### 1 两数之和
思路：用哈希表记录已遍历数字的索引，当前值查补数。

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        seen = {}
        for i, x in enumerate(nums):
            y = target - x
            if y in seen:
                return [seen[y], i]
            seen[x] = i
        return []
```

### 15 三数之和
思路：排序后固定一个数，双指针夹逼并跳过重复。

```python
from typing import List

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        n = len(nums)
        for i in range(n):
            if i and nums[i] == nums[i-1]:
                continue
            l, r = i + 1, n - 1
            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if s == 0:
                    res.append([nums[i], nums[l], nums[r]])
                    l += 1
                    r -= 1
                    while l < r and nums[l] == nums[l-1]:
                        l += 1
                    while l < r and nums[r] == nums[r+1]:
                        r -= 1
                elif s < 0:
                    l += 1
                else:
                    r -= 1
        return res
```

### 11 盛最多水的容器
思路：双指针从两端向内，保留最大面积，移动短板。

```python
from typing import List

class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r = 0, len(height) - 1
        ans = 0
        while l < r:
            ans = max(ans, (r - l) * min(height[l], height[r]))
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return ans
```

### 26 删除有序数组重复项
思路：快慢指针原地覆盖。

```python
from typing import List

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if not nums:
            return 0
        slow = 1
        for fast in range(1, len(nums)):
            if nums[fast] != nums[fast-1]:
                nums[slow] = nums[fast]
                slow += 1
        return slow
```

### 27 移除元素
思路：快慢指针过滤。

```python
from typing import List

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
        return slow
```

### 31 下一个排列
思路：从右找降序断点，交换后缀最小大于它的数并反转后缀。

```python
from typing import List

class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        n = len(nums)
        i = n - 2
        while i >= 0 and nums[i] >= nums[i+1]:
            i -= 1
        if i >= 0:
            j = n - 1
            while nums[j] <= nums[i]:
                j -= 1
            nums[i], nums[j] = nums[j], nums[i]
        l, r = i + 1, n - 1
        while l < r:
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r -= 1
```

### 33 搜索旋转排序数组
思路：二分，根据中点与端点判断哪侧有序。

```python
from typing import List

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            m = (l + r) // 2
            if nums[m] == target:
                return m
            if nums[l] <= nums[m]:
                if nums[l] <= target < nums[m]:
                    r = m - 1
                else:
                    l = m + 1
            else:
                if nums[m] < target <= nums[r]:
                    l = m + 1
                else:
                    r = m - 1
        return -1
```

### 34 在排序数组中查找元素始末
思路：两次二分分别找左边界与右边界。

```python
from typing import List

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def lower_bound(x):
            l, r = 0, len(nums)
            while l < r:
                m = (l + r) // 2
                if nums[m] < x:
                    l = m + 1
                else:
                    r = m
            return l
        left = lower_bound(target)
        right = lower_bound(target + 1) - 1
        if left <= right and left < len(nums) and nums[left] == target:
            return [left, right]
        return [-1, -1]
```

### 39 组合总和
思路：回溯，按序选择避免重复组合。

```python
from typing import List

class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        res = []
        def dfs(start, remain, path):
            if remain == 0:
                res.append(path[:])
                return
            for i in range(start, len(candidates)):
                c = candidates[i]
                if c > remain:
                    break
                path.append(c)
                dfs(i, remain - c, path)
                path.pop()
        dfs(0, target, [])
        return res
```

### 42 接雨水
思路：双指针维护左右最高，谁低就结算谁。

```python
from typing import List

class Solution:
    def trap(self, height: List[int]) -> int:
        l, r = 0, len(height) - 1
        left_max = right_max = 0
        ans = 0
        while l < r:
            if height[l] < height[r]:
                left_max = max(left_max, height[l])
                ans += left_max - height[l]
                l += 1
            else:
                right_max = max(right_max, height[r])
                ans += right_max - height[r]
                r -= 1
        return ans
```

### 45 跳跃游戏 II
思路：贪心分层，记录当前层最远可达。

```python
from typing import List

class Solution:
    def jump(self, nums: List[int]) -> int:
        end = far = steps = 0
        for i in range(len(nums) - 1):
            far = max(far, i + nums[i])
            if i == end:
                steps += 1
                end = far
        return steps
```

### 48 旋转图像
思路：先转置再每行反转。

```python
from typing import List

class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        n = len(matrix)
        for i in range(n):
            for j in range(i + 1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        for row in matrix:
            row.reverse()
```

### 53 最大子数组和
思路：Kadane，滚动维护以当前结尾的最大和。

```python
from typing import List

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        cur = best = nums[0]
        for x in nums[1:]:
            cur = max(x, cur + x)
            best = max(best, cur)
        return best
```

### 55 跳跃游戏
思路：贪心维护最远可达。

```python
from typing import List

class Solution:
    def canJump(self, nums: List[int]) -> bool:
        far = 0
        for i, x in enumerate(nums):
            if i > far:
                return False
            far = max(far, i + x)
        return True
```

### 56 合并区间
思路：排序后线性合并。

```python
from typing import List

class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        res = []
        for s, e in intervals:
            if not res or s > res[-1][1]:
                res.append([s, e])
            else:
                res[-1][1] = max(res[-1][1], e)
        return res
```

### 66 加一
思路：从后进位。

```python
from typing import List

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        for i in range(len(digits) - 1, -1, -1):
            if digits[i] < 9:
                digits[i] += 1
                return digits
            digits[i] = 0
        return [1] + digits
```

### 75 颜色分类
思路：荷兰国旗，三指针。

```python
from typing import List

class Solution:
    def sortColors(self, nums: List[int]) -> None:
        low, mid, high = 0, 0, len(nums) - 1
        while mid <= high:
            if nums[mid] == 0:
                nums[low], nums[mid] = nums[mid], nums[low]
                low += 1
                mid += 1
            elif nums[mid] == 1:
                mid += 1
            else:
                nums[mid], nums[high] = nums[high], nums[mid]
                high -= 1
```

### 88 合并两个有序数组
思路：从后往前放置，避免覆盖。

```python
from typing import List

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        i, j, k = m - 1, n - 1, m + n - 1
        while j >= 0:
            if i >= 0 and nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
```

### 128 最长连续序列
思路：哈希集合，只从序列起点开始扩展。

```python
from typing import List

class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        s = set(nums)
        best = 0
        for x in s:
            if x - 1 not in s:
                y = x
                while y in s:
                    y += 1
                best = max(best, y - x)
        return best
```

### 152 乘积最大子数组
思路：维护当前最大/最小乘积，遇负数交换。

```python
from typing import List

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        cur_max = cur_min = ans = nums[0]
        for x in nums[1:]:
            if x < 0:
                cur_max, cur_min = cur_min, cur_max
            cur_max = max(x, cur_max * x)
            cur_min = min(x, cur_min * x)
            ans = max(ans, cur_max)
        return ans
```

### 283 移动零
思路：快慢指针把非零前移。

```python
from typing import List

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != 0:
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1
```

### 287 寻找重复数
思路：把数组看作链表，Floyd 判环。

```python
from typing import List

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow = fast = nums[0]
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        slow = nums[0]
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow
```

## 链表

### 21 合并两个有序链表
思路：归并指针。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = cur = ListNode()
        while l1 and l2:
            if l1.val <= l2.val:
                cur.next, l1 = l1, l1.next
            else:
                cur.next, l2 = l2, l2.next
            cur = cur.next
        cur.next = l1 or l2
        return dummy.next
```

### 83 删除排序链表重复元素
思路：遍历跳过相同值。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        cur = head
        while cur and cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return head
```

### 141 环形链表
思路：快慢指针相遇判环。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
```

### 142 环形链表 II
思路：Floyd，找入环点。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        else:
            return None
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return slow
```

### 160 相交链表
思路：双指针走完各自后换头，最终相遇。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        a, b = headA, headB
        while a != b:
            a = a.next if a else headB
            b = b.next if b else headA
        return a
```

### 206 反转链表
思路：迭代翻转指针。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        cur = head
        while cur:
            nxt = cur.next
            cur.next = prev
            prev = cur
            cur = nxt
        return prev
```

### 234 回文链表
思路：快慢找中点，反转后半段比较。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        prev = None
        cur = slow
        while cur:
            nxt = cur.next
            cur.next = prev
            prev = cur
            cur = nxt
        left, right = head, prev
        while right:
            if left.val != right.val:
                return False
            left = left.next
            right = right.next
        return True
```

### 876 链表的中间结点
思路：快慢指针。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

## 字符串

### 3 无重复字符的最长子串
思路：滑动窗口，记录字符最新位置。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        last = {}
        left = ans = 0
        for i, ch in enumerate(s):
            if ch in last and last[ch] >= left:
                left = last[ch] + 1
            last[ch] = i
            ans = max(ans, i - left + 1)
        return ans
```

### 5 最长回文子串
思路：中心扩展。

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        def expand(l, r):
            while l >= 0 and r < len(s) and s[l] == s[r]:
                l -= 1
                r += 1
            return s[l+1:r]
        ans = ""
        for i in range(len(s)):
            ans = max(ans, expand(i, i), expand(i, i+1), key=len)
        return ans
```

### 20 有效的括号
思路：栈匹配。

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        mp = {')':'(', ']':'[', '}':'{'}
        for ch in s:
            if ch in mp:
                if not stack or stack.pop() != mp[ch]:
                    return False
            else:
                stack.append(ch)
        return not stack
```

### 28 找出字符串中第一个匹配的下标
思路：KMP 预处理前缀表。

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle == "":
            return 0
        m = len(needle)
        lps = [0] * m
        j = 0
        for i in range(1, m):
            while j > 0 and needle[i] != needle[j]:
                j = lps[j-1]
            if needle[i] == needle[j]:
                j += 1
                lps[i] = j
        j = 0
        for i, ch in enumerate(haystack):
            while j > 0 and ch != needle[j]:
                j = lps[j-1]
            if ch == needle[j]:
                j += 1
                if j == m:
                    return i - m + 1
        return -1
```

### 38 外观数列
思路：模拟读数写数。

```python
class Solution:
    def countAndSay(self, n: int) -> str:
        s = "1"
        for _ in range(n - 1):
            i = 0
            out = []
            while i < len(s):
                j = i
                while j < len(s) and s[j] == s[i]:
                    j += 1
                out.append(str(j - i))
                out.append(s[i])
                i = j
            s = "".join(out)
        return s
```

### 49 字母异位词分组
思路：排序字符串作为键。

```python
from typing import List
from collections import defaultdict

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        mp = defaultdict(list)
        for s in strs:
            key = "".join(sorted(s))
            mp[key].append(s)
        return list(mp.values())
```

### 76 最小覆盖子串
思路：滑动窗口统计需求。

```python
from collections import Counter

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need = Counter(t)
        missing = len(t)
        left = start = 0
        best = float("inf")
        for right, ch in enumerate(s):
            if need[ch] > 0:
                missing -= 1
            need[ch] -= 1
            while missing == 0:
                if right - left + 1 < best:
                    best = right - left + 1
                    start = left
                need[s[left]] += 1
                if need[s[left]] > 0:
                    missing += 1
                left += 1
        return "" if best == float("inf") else s[start:start+best]
```

### 91 解码方法
思路：线性 DP。

```python
class Solution:
    def numDecodings(self, s: str) -> int:
        if not s or s[0] == '0':
            return 0
        prev2, prev1 = 1, 1
        for i in range(1, len(s)):
            cur = 0
            if s[i] != '0':
                cur += prev1
            two = int(s[i-1:i+1])
            if 10 <= two <= 26:
                cur += prev2
            prev2, prev1 = prev1, cur
        return prev1
```

### 125 验证回文串
思路：双指针跳过非字母数字。

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        l, r = 0, len(s) - 1
        while l < r:
            while l < r and not s[l].isalnum():
                l += 1
            while l < r and not s[r].isalnum():
                r -= 1
            if s[l].lower() != s[r].lower():
                return False
            l += 1
            r -= 1
        return True
```

### 242 有效的字母异位词
思路：计数比较。

```python
from collections import Counter

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)
```

## 哈希 & 位运算

### 136 只出现一次的数字
思路：异或抵消。

```python
from typing import List

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        x = 0
        for n in nums:
            x ^= n
        return x
```

### 137 只出现一次的数字 II
思路：统计每一位 1 的个数取模。

```python
from typing import List

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        res = 0
        for b in range(32):
            s = 0
            for x in nums:
                s += (x >> b) & 1
            if s % 3:
                res |= (1 << b)
        if res >= 2**31:
            res -= 2**32
        return res
```

### 191 位1的个数
思路：n & (n-1) 去掉最低位 1。

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        while n:
            n &= n - 1
            cnt += 1
        return cnt
```

### 260 只出现一次的数字 III
思路：整体异或得到两数差异位，按该位分组异或。

```python
from typing import List

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        x = 0
        for n in nums:
            x ^= n
        lowbit = x & -x
        a = b = 0
        for n in nums:
            if n & lowbit:
                a ^= n
            else:
                b ^= n
        return [a, b]
```

### 338 比特位计数
思路：dp[i] = dp[i>>1] + (i&1)。

```python
from typing import List

class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            dp[i] = dp[i >> 1] + (i & 1)
        return dp
```

## 栈 / 队列 / 堆

### 155 最小栈
思路：辅助栈同步维护最小值。

```python
class MinStack:
    def __init__(self):
        self.s = []
        self.min_s = []

    def push(self, val: int) -> None:
        self.s.append(val)
        if not self.min_s or val <= self.min_s[-1]:
            self.min_s.append(val)

    def pop(self) -> None:
        if self.s.pop() == self.min_s[-1]:
            self.min_s.pop()

    def top(self) -> int:
        return self.s[-1]

    def getMin(self) -> int:
        return self.min_s[-1]
```

### 232 用栈实现队列
思路：两个栈进出。

```python
class MyQueue:
    def __init__(self):
        self.in_s = []
        self.out_s = []

    def push(self, x: int) -> None:
        self.in_s.append(x)

    def _move(self):
        if not self.out_s:
            while self.in_s:
                self.out_s.append(self.in_s.pop())

    def pop(self) -> int:
        self._move()
        return self.out_s.pop()

    def peek(self) -> int:
        self._move()
        return self.out_s[-1]

    def empty(self) -> bool:
        return not self.in_s and not self.out_s
```

### 239 滑动窗口最大值
思路：单调队列存索引。

```python
from typing import List
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        q = deque()
        res = []
        for i, x in enumerate(nums):
            while q and nums[q[-1]] <= x:
                q.pop()
            q.append(i)
            if q[0] <= i - k:
                q.popleft()
            if i >= k - 1:
                res.append(nums[q[0]])
        return res
```

### 295 数据流的中位数
思路：大小根堆平衡。

```python
import heapq

class MedianFinder:
    def __init__(self):
        self.small = []
        self.large = []

    def addNum(self, num: int) -> None:
        if not self.small or num <= -self.small[0]:
            heapq.heappush(self.small, -num)
        else:
            heapq.heappush(self.large, num)
        if len(self.small) > len(self.large) + 1:
            heapq.heappush(self.large, -heapq.heappop(self.small))
        if len(self.large) > len(self.small):
            heapq.heappush(self.small, -heapq.heappop(self.large))

    def findMedian(self) -> float:
        if len(self.small) > len(self.large):
            return float(-self.small[0])
        return (-self.small[0] + self.large[0]) / 2.0
```

### 739 每日温度
思路：单调栈存索引。

```python
from typing import List

class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        res = [0] * len(temperatures)
        stack = []
        for i, t in enumerate(temperatures):
            while stack and temperatures[stack[-1]] < t:
                j = stack.pop()
                res[j] = i - j
            stack.append(i)
        return res
```

## 二叉树 / 二叉搜索树

### 94 二叉树中序遍历
思路：递归遍历。

```python
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def dfs(node):
            if not node:
                return
            dfs(node.left)
            res.append(node.val)
            dfs(node.right)
        dfs(root)
        return res
```

### 98 验证二叉搜索树
思路：中序递增。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        prev = None
        def dfs(node):
            nonlocal prev
            if not node:
                return True
            if not dfs(node.left):
                return False
            if prev is not None and node.val <= prev:
                return False
            prev = node.val
            return dfs(node.right)
        return dfs(root)
```

### 100 相同的树
思路：递归比较。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p or not q:
            return p == q
        if p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

### 101 对称二叉树
思路：递归比较镜像子树。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def mirror(a, b):
            if not a or not b:
                return a == b
            if a.val != b.val:
                return False
            return mirror(a.left, b.right) and mirror(a.right, b.left)
        return mirror(root, root)
```

### 102 二叉树层序遍历
思路：BFS 队列。

```python
from typing import List, Optional
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        res = []
        q = deque([root])
        while q:
            level = []
            for _ in range(len(q)):
                node = q.popleft()
                level.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            res.append(level)
        return res
```

### 104 二叉树最大深度
思路：DFS 深度。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```

### 105 从前序与中序构造二叉树
思路：前序定根，中序分左右。

```python
from typing import Optional, List

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        idx = {v:i for i, v in enumerate(inorder)}
        it = iter(preorder)
        def helper(l, r):
            if l > r:
                return None
            root_val = next(it)
            mid = idx[root_val]
            root = TreeNode(root_val)
            root.left = helper(l, mid - 1)
            root.right = helper(mid + 1, r)
            return root
        return helper(0, len(inorder) - 1)
```

### 108 将有序数组转为 BST
思路：二分选中点为根。

```python
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def build(l, r):
            if l > r:
                return None
            m = (l + r) // 2
            root = TreeNode(nums[m])
            root.left = build(l, m - 1)
            root.right = build(m + 1, r)
            return root
        return build(0, len(nums) - 1)
```

### 110 平衡二叉树
思路：自底向上返回高度，失衡返回 -1。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def height(node):
            if not node:
                return 0
            lh = height(node.left)
            if lh == -1:
                return -1
            rh = height(node.right)
            if rh == -1 or abs(lh - rh) > 1:
                return -1
            return 1 + max(lh, rh)
        return height(root) != -1
```

### 124 二叉树最大路径和
思路：后序返回单边最大，更新全局答案。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        ans = -10**18
        def dfs(node):
            nonlocal ans
            if not node:
                return 0
            l = max(dfs(node.left), 0)
            r = max(dfs(node.right), 0)
            ans = max(ans, node.val + l + r)
            return node.val + max(l, r)
        dfs(root)
        return ans
```

### 144 前序遍历
思路：迭代栈。

```python
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        res = []
        stack = [root]
        while stack:
            node = stack.pop()
            res.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return res
```

### 145 后序遍历
思路：迭代，先根右左再反转。

```python
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        res = []
        stack = [root]
        while stack:
            node = stack.pop()
            res.append(node.val)
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        return res[::-1]
```

### 199 二叉树右视图
思路：层序最后一个节点。

```python
from typing import List, Optional
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        res = []
        q = deque([root])
        while q:
            size = len(q)
            for i in range(size):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                if i == size - 1:
                    res.append(node.val)
        return res
```

### 226 翻转二叉树
思路：递归交换左右。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)
        return root
```

### 236 二叉树最近公共祖先
思路：递归返回命中节点。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q:
            return root
        l = self.lowestCommonAncestor(root.left, p, q)
        r = self.lowestCommonAncestor(root.right, p, q)
        if l and r:
            return root
        return l or r
```

### 297 二叉树序列化与反序列化
思路：前序 DFS 序列化，反序列化按序构建。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Codec:
    def serialize(self, root: Optional[TreeNode]) -> str:
        res = []
        def dfs(node):
            if not node:
                res.append('#')
                return
            res.append(str(node.val))
            dfs(node.left)
            dfs(node.right)
        dfs(root)
        return ",".join(res)

    def deserialize(self, data: str) -> Optional[TreeNode]:
        vals = iter(data.split(','))
        def dfs():
            v = next(vals)
            if v == '#':
                return None
            node = TreeNode(int(v))
            node.left = dfs()
            node.right = dfs()
            return node
        return dfs()
```

## 回溯 / DFS / BFS

### 17 电话号码的字母组合
思路：回溯枚举。

```python
from typing import List

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        mp = {
            '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
            '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
        }
        res = []
        def dfs(i, path):
            if i == len(digits):
                res.append("".join(path))
                return
            for ch in mp[digits[i]]:
                path.append(ch)
                dfs(i + 1, path)
                path.pop()
        dfs(0, [])
        return res
```

### 22 括号生成
思路：回溯控制左右括号数量。

```python
from typing import List

class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def dfs(l, r, path):
            if len(path) == 2 * n:
                res.append("".join(path))
                return
            if l < n:
                path.append('(')
                dfs(l + 1, r, path)
                path.pop()
            if r < l:
                path.append(')')
                dfs(l, r + 1, path)
                path.pop()
        dfs(0, 0, [])
        return res
```

### 46 全排列
思路：回溯+使用标记。

```python
from typing import List

class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        used = [False] * len(nums)
        def dfs(path):
            if len(path) == len(nums):
                res.append(path[:])
                return
            for i in range(len(nums)):
                if used[i]:
                    continue
                used[i] = True
                path.append(nums[i])
                dfs(path)
                path.pop()
                used[i] = False
        dfs([])
        return res
```

### 47 全排列 II
思路：排序后去重。

```python
from typing import List

class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        used = [False] * len(nums)
        def dfs(path):
            if len(path) == len(nums):
                res.append(path[:])
                return
            for i in range(len(nums)):
                if used[i]:
                    continue
                if i > 0 and nums[i] == nums[i-1] and not used[i-1]:
                    continue
                used[i] = True
                path.append(nums[i])
                dfs(path)
                path.pop()
                used[i] = False
        dfs([])
        return res
```

### 78 子集
思路：回溯枚举选/不选。

```python
from typing import List

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        def dfs(i, path):
            if i == len(nums):
                res.append(path[:])
                return
            dfs(i + 1, path)
            path.append(nums[i])
            dfs(i + 1, path)
            path.pop()
        dfs(0, [])
        return res
```

### 79 单词搜索
思路：DFS 回溯标记访问。

```python
from typing import List

class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        m, n = len(board), len(board[0])
        def dfs(i, j, k):
            if k == len(word):
                return True
            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]:
                return False
            tmp = board[i][j]
            board[i][j] = '#'
            ok = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)
            board[i][j] = tmp
            return ok
        for i in range(m):
            for j in range(n):
                if dfs(i, j, 0):
                    return True
        return False
```

### 200 岛屿数量
思路：DFS 或 BFS 遍历连通块。

```python
from typing import List

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        m, n = len(grid), len(grid[0])
        def dfs(i, j):
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':
                return
            grid[i][j] = '0'
            dfs(i+1, j); dfs(i-1, j); dfs(i, j+1); dfs(i, j-1)
        cnt = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    cnt += 1
                    dfs(i, j)
        return cnt
```

### 301 删除无效的括号
思路：BFS 逐层删除，首次找到即最短。

```python
from typing import List
from collections import deque

class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        def valid(t):
            bal = 0
            for ch in t:
                if ch == '(':
                    bal += 1
                elif ch == ')':
                    bal -= 1
                    if bal < 0:
                        return False
            return bal == 0
        res = []
        visited = {s}
        q = deque([s])
        found = False
        while q:
            t = q.popleft()
            if valid(t):
                res.append(t)
                found = True
            if found:
                continue
            for i in range(len(t)):
                if t[i] not in "()":
                    continue
                nt = t[:i] + t[i+1:]
                if nt not in visited:
                    visited.add(nt)
                    q.append(nt)
        return res
```

## 动态规划（简单 → 困难）

### 70 爬楼梯
思路：斐波那契 DP。

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        a, b = 1, 1
        for _ in range(n):
            a, b = b, a + b
        return a
```

### 118 杨辉三角
思路：逐行生成。

```python
from typing import List

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        for i in range(numRows):
            row = [1] * (i + 1)
            for j in range(1, i):
                row[j] = res[i-1][j-1] + res[i-1][j]
            res.append(row)
        return res
```

### 121 买卖股票最佳时机
思路：维护历史最低价。

```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        low = 10**9
        ans = 0
        for p in prices:
            low = min(low, p)
            ans = max(ans, p - low)
        return ans
```

### 122 买卖股票最佳时机 II
思路：累计所有上升差价。

```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                ans += prices[i] - prices[i-1]
        return ans
```

### 198 打家劫舍
思路：DP 滚动。

```python
from typing import List

class Solution:
    def rob(self, nums: List[int]) -> int:
        prev2, prev1 = 0, 0
        for x in nums:
            prev2, prev1 = prev1, max(prev1, prev2 + x)
        return prev1
```

### 213 打家劫舍 II
思路：环拆两段取最大。

```python
from typing import List

class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        def rob_line(arr):
            prev2, prev1 = 0, 0
            for x in arr:
                prev2, prev1 = prev1, max(prev1, prev2 + x)
            return prev1
        return max(rob_line(nums[:-1]), rob_line(nums[1:]))
```

### 139 单词拆分
思路：DP + 词典集合。

```python
from typing import List

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        word = set(wordDict)
        dp = [False] * (len(s) + 1)
        dp[0] = True
        for i in range(1, len(s) + 1):
            for j in range(i):
                if dp[j] and s[j:i] in word:
                    dp[i] = True
                    break
        return dp[-1]
```

### 300 最长递增子序列
思路：贪心+二分维护尾数组。

```python
from typing import List
import bisect

class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        tails = []
        for x in nums:
            i = bisect.bisect_left(tails, x)
            if i == len(tails):
                tails.append(x)
            else:
                tails[i] = x
        return len(tails)
```

### 322 零钱兑换
思路：完全背包最小值。

```python
from typing import List

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [10**9] * (amount + 1)
        dp[0] = 0
        for a in range(1, amount + 1):
            for c in coins:
                if c <= a:
                    dp[a] = min(dp[a], dp[a - c] + 1)
        return -1 if dp[amount] == 10**9 else dp[amount]
```

### 416 分割等和子集
思路：0-1 背包。

```python
from typing import List

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        s = sum(nums)
        if s % 2:
            return False
        target = s // 2
        dp = [False] * (target + 1)
        dp[0] = True
        for x in nums:
            for t in range(target, x - 1, -1):
                dp[t] = dp[t] or dp[t - x]
        return dp[target]
```

### 518 零钱兑换 II
思路：组合数，外层遍历硬币。

```python
from typing import List

class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount + 1)
        dp[0] = 1
        for c in coins:
            for a in range(c, amount + 1):
                dp[a] += dp[a - c]
        return dp[amount]
```

### 64 最小路径和
思路：网格 DP。

```python
from typing import List

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [10**9] * n
        dp[0] = 0
        for i in range(m):
            dp[0] += grid[i][0]
            for j in range(1, n):
                dp[j] = min(dp[j], dp[j-1]) + grid[i][j]
        return dp[-1]
```

### 72 编辑距离
思路：二维 DP 变换。

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)
        dp = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m+1):
            dp[i][0] = i
        for j in range(n+1):
            dp[0][j] = j
        for i in range(1, m+1):
            for j in range(1, n+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
        return dp[m][n]
```

### 221 最大正方形
思路：dp[i][j] 为右下角正方形边长。

```python
from typing import List

class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix:
            return 0
        m, n = len(matrix), len(matrix[0])
        dp = [0] * (n + 1)
        ans = 0
        for i in range(1, m + 1):
            prev = 0
            for j in range(1, n + 1):
                temp = dp[j]
                if matrix[i-1][j-1] == '1':
                    dp[j] = min(dp[j], dp[j-1], prev) + 1
                    ans = max(ans, dp[j])
                else:
                    dp[j] = 0
                prev = temp
        return ans * ans
```

### 279 完全平方数
思路：完全背包最少数。

```python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [10**9] * (n + 1)
        dp[0] = 0
        i = 1
        while i * i <= n:
            sq = i * i
            for j in range(sq, n + 1):
                dp[j] = min(dp[j], dp[j - sq] + 1)
            i += 1
        return dp[n]
```

### 309 最佳买卖股票时机含冷冻期
思路：状态机 DP。

```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        hold = -10**9
        sold = 0
        rest = 0
        for p in prices:
            prev_sold = sold
            sold = hold + p
            hold = max(hold, rest - p)
            rest = max(rest, prev_sold)
        return max(sold, rest)
```

### 337 打家劫舍 III
思路：树形 DP 返回抢/不抢。

```python
from typing import Optional, Tuple

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        def dfs(node) -> Tuple[int, int]:
            if not node:
                return (0, 0)
            l0, l1 = dfs(node.left)
            r0, r1 = dfs(node.right)
            rob = node.val + l0 + r0
            skip = max(l0, l1) + max(r0, r1)
            return (skip, rob)
        skip, rob = dfs(root)
        return max(skip, rob)
```

## 贪心

### 406 根据身高重建队列
思路：按身高降序、k 升序插入。

```python
from typing import List

class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda x: (-x[0], x[1]))
        res = []
        for p in people:
            res.insert(p[1], p)
        return res
```

## 图论 / 拓扑 / 并查集 / 最短路

### 207 课程表
思路：拓扑排序判环。

```python
from typing import List
from collections import deque

class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        g = [[] for _ in range(numCourses)]
        indeg = [0] * numCourses
        for a, b in prerequisites:
            g[b].append(a)
            indeg[a] += 1
        q = deque([i for i in range(numCourses) if indeg[i] == 0])
        seen = 0
        while q:
            u = q.popleft()
            seen += 1
            for v in g[u]:
                indeg[v] -= 1
                if indeg[v] == 0:
                    q.append(v)
        return seen == numCourses
```

### 210 课程表 II
思路：拓扑排序输出顺序。

```python
from typing import List
from collections import deque

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        g = [[] for _ in range(numCourses)]
        indeg = [0] * numCourses
        for a, b in prerequisites:
            g[b].append(a)
            indeg[a] += 1
        q = deque([i for i in range(numCourses) if indeg[i] == 0])
        res = []
        while q:
            u = q.popleft()
            res.append(u)
            for v in g[u]:
                indeg[v] -= 1
                if indeg[v] == 0:
                    q.append(v)
        return res if len(res) == numCourses else []
```

### 684 冗余连接
思路：并查集，出现环的边即答案。

```python
from typing import List

class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        parent = {}
        def find(x):
            parent.setdefault(x, x)
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        def union(a, b):
            pa, pb = find(a), find(b)
            if pa == pb:
                return False
            parent[pa] = pb
            return True
        for a, b in edges:
            if not union(a, b):
                return [a, b]
        return []
```

### 785 判断二分图
思路：DFS 染色。

```python
from typing import List

class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        color = [0] * n
        def dfs(u, c):
            color[u] = c
            for v in graph[u]:
                if color[v] == c:
                    return False
                if color[v] == 0 and not dfs(v, -c):
                    return False
            return True
        for i in range(n):
            if color[i] == 0 and not dfs(i, 1):
                return False
        return True
```

### 127 单词接龙
思路：双向 BFS。

```python
from typing import List

class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordSet = set(wordList)
        if endWord not in wordSet:
            return 0
        begin, end = {beginWord}, {endWord}
        step = 1
        while begin and end:
            if len(begin) > len(end):
                begin, end = end, begin
            nxt = set()
            for w in begin:
                for i in range(len(w)):
                    for c in "abcdefghijklmnopqrstuvwxyz":
                        nw = w[:i] + c + w[i+1:]
                        if nw in end:
                            return step + 1
                        if nw in wordSet:
                            wordSet.remove(nw)
                            nxt.add(nw)
            begin = nxt
            step += 1
        return 0
```

### 994 腐烂的橘子
思路：多源 BFS。

```python
from typing import List
from collections import deque

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        q = deque()
        fresh = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 2:
                    q.append((i, j))
                elif grid[i][j] == 1:
                    fresh += 1
        minutes = 0
        dirs = [(1,0),(-1,0),(0,1),(0,-1)]
        while q and fresh:
            for _ in range(len(q)):
                i, j = q.popleft()
                for di, dj in dirs:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:
                        grid[ni][nj] = 2
                        fresh -= 1
                        q.append((ni, nj))
            minutes += 1
        return minutes if fresh == 0 else -1
```

## 二分 & 数学

### 69 x 的平方根
思路：二分取整。

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r = 0, x
        while l <= r:
            m = (l + r) // 2
            if m * m <= x:
                l = m + 1
            else:
                r = m - 1
        return r
```

### 50 Pow(x, n)
思路：快速幂。

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1.0
        if n < 0:
            x, n = 1 / x, -n
        res = 1.0
        while n:
            if n & 1:
                res *= x
            x *= x
            n >>= 1
        return res
```

### 172 阶乘后的零
思路：统计因子 5 的数量。

```python
class Solution:
    def trailingZeroes(self, n: int) -> int:
        ans = 0
        while n:
            n //= 5
            ans += n
        return ans
```

### 367 有效的完全平方数
思路：二分。

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        l, r = 1, num
        while l <= r:
            m = (l + r) // 2
            sq = m * m
            if sq == num:
                return True
            if sq < num:
                l = m + 1
            else:
                r = m - 1
        return num == 1
```

## 滑动窗口 / 双指针

### 438 找到字符串中所有字母异位词
思路：固定窗口计数比较。

```python
from typing import List
from collections import Counter

class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        if len(p) > len(s):
            return []
        res = []
        need = Counter(p)
        window = Counter(s[:len(p)])
        if window == need:
            res.append(0)
        for i in range(len(p), len(s)):
            window[s[i]] += 1
            window[s[i - len(p)]] -= 1
            if window[s[i - len(p)]] == 0:
                del window[s[i - len(p)]]
            if window == need:
                res.append(i - len(p) + 1)
        return res
```

## Trie / 字符串匹配

### 208 实现 Trie
思路：字典树节点记录 children 与结尾标记。

```python
class Trie:
    def __init__(self):
        self.children = {}
        self.end = False

    def insert(self, word: str) -> None:
        node = self
        for ch in word:
            node = node.children.setdefault(ch, Trie())
        node.end = True

    def search(self, word: str) -> bool:
        node = self
        for ch in word:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return node.end

    def startsWith(self, prefix: str) -> bool:
        node = self
        for ch in prefix:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return True
```

### 212 单词搜索 II
思路：Trie + DFS 剪枝。

```python
from typing import List

class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = None

class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        root = TrieNode()
        for w in words:
            node = root
            for ch in w:
                node = node.children.setdefault(ch, TrieNode())
            node.word = w
        m, n = len(board), len(board[0])
        res = []
        def dfs(i, j, node):
            ch = board[i][j]
            if ch not in node.children:
                return
            nxt = node.children[ch]
            if nxt.word:
                res.append(nxt.word)
                nxt.word = None
            board[i][j] = '#'
            for di, dj in [(1,0),(-1,0),(0,1),(0,-1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < m and 0 <= nj < n and board[ni][nj] != '#':
                    dfs(ni, nj, nxt)
            board[i][j] = ch
            if not nxt.children:
                node.children.pop(ch, None)
        for i in range(m):
            for j in range(n):
                dfs(i, j, root)
        return res
```

## 高级数据结构

### 146 LRU 缓存
思路：哈希 + 双向链表。

```python
class Node:
    def __init__(self, k=0, v=0):
        self.k = k
        self.v = v
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.cap = capacity
        self.mp = {}
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head

    def _remove(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def _add(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    def get(self, key: int) -> int:
        if key not in self.mp:
            return -1
        node = self.mp[key]
        self._remove(node)
        self._add(node)
        return node.v

    def put(self, key: int, value: int) -> None:
        if key in self.mp:
            node = self.mp[key]
            node.v = value
            self._remove(node)
            self._add(node)
            return
        if len(self.mp) == self.cap:
            lru = self.tail.prev
            self._remove(lru)
            self.mp.pop(lru.k, None)
        node = Node(key, value)
        self.mp[key] = node
        self._add(node)
```

### 460 LFU 缓存
思路：双哈希 + 频次链表。

```python
from collections import defaultdict

class Node:
    def __init__(self, k=0, v=0):
        self.k = k
        self.v = v
        self.freq = 1

class LFUCache:
    def __init__(self, capacity: int):
        self.cap = capacity
        self.minf = 0
        self.nodes = {}
        self.freqs = defaultdict(dict)

    def _touch(self, node: Node):
        f = node.freq
        self.freqs[f].pop(node.k, None)
        if not self.freqs[f] and self.minf == f:
            self.minf += 1
        node.freq += 1
        self.freqs[node.freq][node.k] = node

    def get(self, key: int) -> int:
        if key not in self.nodes:
            return -1
        node = self.nodes[key]
        self._touch(node)
        return node.v

    def put(self, key: int, value: int) -> None:
        if self.cap == 0:
            return
        if key in self.nodes:
            node = self.nodes[key]
            node.v = value
            self._touch(node)
            return
        if len(self.nodes) == self.cap:
            k, _ = next(iter(self.freqs[self.minf].items()))
            self.freqs[self.minf].pop(k, None)
            self.nodes.pop(k, None)
        node = Node(key, value)
        self.nodes[key] = node
        self.freqs[1][key] = node
        self.minf = 1
```
