# LeetCode 热题清单（去重版）

以下内容按你提供的分类与顺序整理，重复题目已在首次出现处保留，后续分类中不再重复。每题包含简要思路与可运行 Python 解法（LeetCode 习惯的 `Solution` 形式）。

## 哈希 / 双指针 / 数组

### 1 两数之和
题目：给定一个整数数组 `nums` 和一个目标值 `target`，在数组中找出两个数，使它们的和等于 `target`，返回这两个数的索引（任意顺序）。
示例：输入：nums = [2,7,11,15], target = 9；输出：[0,1]
思路：用哈希表记录已遍历数字的索引，当前值查补数。

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        seen = {}
        for index, value in enumerate(nums):
            complement = target - value
            if complement in seen:
                return [seen[complement], index]
            seen[value] = index
        return []
```

### 15 三数之和
题目：给定整数数组 `nums`，找出所有和为 0 的不重复三元组。
示例：输入：nums = [-1,0,1,2,-1,-4]；输出：[[-1,-1,2],[-1,0,1]]
思路：排序后固定一个数，双指针夹逼并跳过重复。

```python
from typing import List

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        length = len(nums)
        for first_idx in range(length):
            if first_idx and nums[first_idx] == nums[first_idx-1]:
                continue
            left, right = first_idx + 1, length - 1
            while left < right:
                text = nums[first_idx] + nums[left] + nums[right]
                if text == 0:
                    res.append([nums[first_idx], nums[left], nums[right]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left-1]:
                        left += 1
                    while left < right and nums[right] == nums[right+1]:
                        right -= 1
                elif text < 0:
                    left += 1
                else:
                    right -= 1
        return res
```

### 11 盛最多水的容器
题目：给定数组 `height` 表示竖线高度，选择两条线与 x 轴围成容器，返回能盛水的最大面积。
示例：输入：height = [1,8,6,2,5,4,8,3,7]；输出：49
思路：双指针从两端向内，保留最大面积，移动短板。

```python
from typing import List

class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        ans = 0
        while left < right:
            ans = max(ans, (right - left) * min(height[left], height[right]))
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        return ans
```

### 26 删除有序数组重复项
题目：给定升序数组 `nums`，原地删除重复元素，使每个元素只出现一次，返回新长度。
示例：输入：nums = [1,1,2]；输出：2（前两个元素为 1,2）
思路：快慢指针原地覆盖。

```python
from typing import List

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if not nums:
            return 0
        slow = 1
        for fast in range(1, len(nums)):
            if nums[fast] != nums[fast-1]:
                nums[slow] = nums[fast]
                slow += 1
        return slow
```

### 27 移除元素
题目：给定数组 `nums` 和值 `val`，原地移除所有等于 `val` 的元素，返回新长度。
示例：输入：nums = [3,2,2,3], val = 3；输出：2（前两个元素为 2,2）
思路：快慢指针过滤。

```python
from typing import List

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
        return slow
```

### 31 下一个排列
题目：给定整数数组表示一个排列，将其改为字典序下一个更大的排列；若不存在则改为最小排列。
示例：输入：nums = [1,2,3]；输出：[1,3,2]
思路：从右找降序断点，交换后缀最小大于它的数并反转后缀。

```python
from typing import List

class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        length = len(nums)
        pivot = length - 2
        while pivot >= 0 and nums[pivot] >= nums[pivot+1]:
            pivot -= 1
        if pivot >= 0:
            swap_idx = length - 1
            while nums[swap_idx] <= nums[pivot]:
                swap_idx -= 1
            nums[pivot], nums[swap_idx] = nums[swap_idx], nums[pivot]
        left, right = pivot + 1, length - 1
        while left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
```

### 33 搜索旋转排序数组
题目：给定旋转过的升序数组 `nums` 和目标值 `target`，返回其索引，不存在则返回 -1。
示例：输入：nums = [4,5,6,7,0,1,2], target = 0；输出：4
思路：二分，根据中点与端点判断哪侧有序。

```python
from typing import List

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[left] <= nums[mid]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
```

### 34 在排序数组中查找元素始末
题目：给定升序数组 `nums` 和目标值 `target`，返回其起始和结束位置，不存在返回 [-1,-1]。
示例：输入：nums = [5,7,7,8,8,10], target = 8；输出：[3,4]
思路：两次二分分别找左边界与右边界。

```python
from typing import List

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def lower_bound(value):
            left, right = 0, len(nums)
            while left < right:
                mid = (left + right) // 2
                if nums[mid] < value:
                    left = mid + 1
                else:
                    right = mid
            return left
        left = lower_bound(target)
        right = lower_bound(target + 1) - 1
        if left <= right and left < len(nums) and nums[left] == target:
            return [left, right]
        return [-1, -1]
```

### 39 组合总和
题目：给定无重复整数数组 `candidates` 和目标值 `target`，找出所有和为 `target` 的组合（元素可重复选）。
示例：输入：candidates = [2,3,6,7], target = 7；输出：[[2,2,3],[7]]
思路：回溯，按序选择避免重复组合。

```python
from typing import List

class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        res = []
        def dfs(start, remain, path):
            if remain == 0:
                res.append(path[:])
                return
            for cand_idx in range(start, len(candidates)):
                value = candidates[cand_idx]
                if value > remain:
                    break
                path.append(value)
                dfs(cand_idx, remain - value, path)
                path.pop()
        dfs(0, target, [])
        return res
```

### 42 接雨水
题目：给定非负整数数组 `height` 表示柱子高度，计算能接住的雨水总量。
示例：输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]；输出：6
思路：双指针维护左右最高，谁低就结算谁。

```python
from typing import List

class Solution:
    def trap(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        left_max = right_max = 0
        ans = 0
        while left < right:
            if height[left] < height[right]:
                left_max = max(left_max, height[left])
                ans += left_max - height[left]
                left += 1
            else:
                right_max = max(right_max, height[right])
                ans += right_max - height[right]
                right -= 1
        return ans
```

### 45 跳跃游戏 II
题目：给定数组 `nums`，每个元素表示最大跳跃长度，求到达最后位置的最少跳跃次数。
示例：输入：nums = [2,3,1,1,4]；输出：2
思路：贪心分层，记录当前层最远可达。

```python
from typing import List

class Solution:
    def jump(self, nums: List[int]) -> int:
        end = far = steps = 0
        for index in range(len(nums) - 1):
            far = max(far, index + nums[index])
            if index == end:
                steps += 1
                end = far
        return steps
```

### 48 旋转图像
题目：给定 n×n 矩阵，原地将其顺时针旋转 90 度。
示例：输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]；输出：[[7,4,1],[8,5,2],[9,6,3]]
思路：先转置再每行反转。

```python
from typing import List

class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        length = len(matrix)
        for index in range(length):
            for index2 in range(index + 1, length):
                matrix[index][index2], matrix[index2][index] = matrix[index2][index], matrix[index][index2]
        for row in matrix:
            row.reverse()
```

### 53 最大子数组和
题目：给定整数数组 `nums`，返回连续子数组的最大和。
示例：输入：nums = [-2,1,-3,4,-1,2,1,-5,4]；输出：6
思路：Kadane，滚动维护以当前结尾的最大和。

```python
from typing import List

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        cur = best = nums[0]
        for value in nums[1:]:
            cur = max(value, cur + value)
            best = max(best, cur)
        return best
```

### 55 跳跃游戏
题目：给定数组 `nums`，每个元素表示最大跳跃长度，判断是否能到达最后位置。
示例：输入：nums = [2,3,1,1,4]；输出：True
思路：贪心维护最远可达。

```python
from typing import List

class Solution:
    def canJump(self, nums: List[int]) -> bool:
        far = 0
        for index, value in enumerate(nums):
            if index > far:
                return False
            far = max(far, index + value)
        return True
```

### 56 合并区间
题目：给定若干区间，合并所有重叠的区间并返回结果。
示例：输入：intervals = [[1,3],[2,6],[8,10],[15,18]]；输出：[[1,6],[8,10],[15,18]]
思路：排序后线性合并。

```python
from typing import List

class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        res = []
        for start, end in intervals:
            if not res or start > res[-1][1]:
                res.append([start, end])
            else:
                res[-1][1] = max(res[-1][1], end)
        return res
```

### 66 加一
题目：给定由数字组成的数组表示非负整数，对该整数加一并返回结果数组。
示例：输入：digits = [1,2,3]；输出：[1,2,4]
思路：从后进位。

```python
from typing import List

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        for index in range(len(digits) - 1, -1, -1):
            if digits[index] < 9:
                digits[index] += 1
                return digits
            digits[index] = 0
        return [1] + digits
```

### 75 颜色分类
题目：给定只包含 0、1、2 的数组，原地排序使相同颜色相邻。
示例：输入：nums = [2,0,2,1,1,0]；输出：[0,0,1,1,2,2]
思路：荷兰国旗，三指针。

```python
from typing import List

class Solution:
    def sortColors(self, nums: List[int]) -> None:
        low, mid, high = 0, 0, len(nums) - 1
        while mid <= high:
            if nums[mid] == 0:
                nums[low], nums[mid] = nums[mid], nums[low]
                low += 1
                mid += 1
            elif nums[mid] == 1:
                mid += 1
            else:
                nums[mid], nums[high] = nums[high], nums[mid]
                high -= 1
```

### 88 合并两个有序数组
题目：给定两个升序数组 `nums1`、`nums2`，将 `nums2` 合并到 `nums1` 中成为一个升序数组。
示例：输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3；输出：nums1 = [1,2,2,3,5,6]
思路：从后往前放置，避免覆盖。

```python
from typing import List

class Solution:
    def merge(self, nums1: List[int], mid: int, nums2: List[int], length: int) -> None:
        index, index2, key = mid - 1, length - 1, mid + length - 1
        while index2 >= 0:
            if index >= 0 and nums1[index] > nums2[index2]:
                nums1[key] = nums1[index]
                index -= 1
            else:
                nums1[key] = nums2[index2]
                index2 -= 1
            key -= 1
```

### 128 最长连续序列
题目：给定未排序数组 `nums`，返回最长连续序列的长度，要求时间复杂度为 O(n)。
示例：输入：nums = [100,4,200,1,3,2]；输出：4
思路：哈希集合，只从序列起点开始扩展。

```python
from typing import List

class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        text = set(nums)
        best = 0
        for value in text:
            if value - 1 not in text:
                other = value
                while other in text:
                    other += 1
                best = max(best, other - value)
        return best
```

### 152 乘积最大子数组
题目：给定整数数组 `nums`，返回连续子数组的最大乘积。
示例：输入：nums = [2,3,-2,4]；输出：6
思路：维护当前最大/最小乘积，遇负数交换。

```python
from typing import List

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        cur_max = cur_min = ans = nums[0]
        for value in nums[1:]:
            if value < 0:
                cur_max, cur_min = cur_min, cur_max
            cur_max = max(value, cur_max * value)
            cur_min = min(value, cur_min * value)
            ans = max(ans, cur_max)
        return ans
```

### 283 移动零
题目：给定数组 `nums`，将所有 0 移到末尾，并保持非零元素的相对顺序。
示例：输入：nums = [0,1,0,3,12]；输出：[1,3,12,0,0]
思路：快慢指针把非零前移。

```python
from typing import List

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != 0:
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1
```

### 287 寻找重复数
题目：给定包含 n+1 个整数的数组，元素在 [1,n] 范围内，只有一个重复数，找出该重复数。
示例：输入：nums = [1,3,4,2,2]；输出：2
思路：把数组看作链表，Floyd 判环。

```python
from typing import List

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow = fast = nums[0]
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        slow = nums[0]
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow
```

## 链表

### 21 合并两个有序链表
题目：给定两个升序链表，合并为一个新的升序链表并返回。
示例：输入：l1 = [1,2,4], l2 = [1,3,4]；输出：[1,1,2,3,4,4]
思路：归并指针。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = cur = ListNode()
        while l1 and l2:
            if l1.val <= l2.val:
                cur.next, l1 = l1, l1.next
            else:
                cur.next, l2 = l2, l2.next
            cur = cur.next
        cur.next = l1 or l2
        return dummy.next
```

### 83 删除排序链表重复元素
题目：给定升序链表，删除所有重复节点，使每个值只出现一次。
示例：输入：head = [1,1,2,3,3]；输出：[1,2,3]
思路：遍历跳过相同值。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        cur = head
        while cur and cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return head
```

### 141 环形链表
题目：给定链表头节点，判断链表中是否存在环。
示例：输入：head = [3,2,0,-4], pos = 1；输出：True
思路：快慢指针相遇判环。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
```

### 142 环形链表 II
题目：给定链表头节点，如果链表有环则返回入环的第一个节点，否则返回 None。
示例：输入：head = [3,2,0,-4], pos = 1；输出：索引 1 处节点
思路：Floyd，找入环点。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        else:
            return None
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return slow
```

### 160 相交链表
题目：给定两条链表的头节点，返回它们相交的节点，不相交则返回 None。
示例：输入：A = [4,1,8,4,5], B = [5,6,1,8,4,5]；输出：值为 8 的节点
思路：双指针走完各自后换头，最终相遇。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        first, second = headA, headB
        while first != second:
            first = first.next if first else headB
            second = second.next if second else headA
        return first
```

### 206 反转链表
题目：给定链表头节点，反转链表并返回新头节点。
示例：输入：head = [1,2,3,4,5]；输出：[5,4,3,2,1]
思路：迭代翻转指针。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        cur = head
        while cur:
            nxt = cur.next
            cur.next = prev
            prev = cur
            cur = nxt
        return prev
```

### 234 回文链表
题目：给定链表头节点，判断链表是否为回文。
示例：输入：head = [1,2,2,1]；输出：True
思路：快慢找中点，反转后半段比较。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        prev = None
        cur = slow
        while cur:
            nxt = cur.next
            cur.next = prev
            prev = cur
            cur = nxt
        left, right = head, prev
        while right:
            if left.val != right.val:
                return False
            left = left.next
            right = right.next
        return True
```

### 876 链表的中间结点
题目：给定非空链表，返回其中间节点；如果有两个中间节点，返回第二个。
示例：输入：head = [1,2,3,4,5,6]；输出：4
思路：快慢指针。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

## 字符串

### 3 无重复字符的最长子串
题目：给定字符串 `s`，找出不含重复字符的最长子串长度。
示例：输入：s = abcabcbb；输出：3
思路：滑动窗口，记录字符最新位置。

```python
class Solution:
    def lengthOfLongestSubstring(self, text: str) -> int:
        last = {}
        left = ans = 0
        for index, ch in enumerate(text):
            if ch in last and last[ch] >= left:
                left = last[ch] + 1
            last[ch] = index
            ans = max(ans, index - left + 1)
        return ans
```

### 5 最长回文子串
题目：给定字符串 `s`，返回其最长回文子串。
示例：输入：s = babad；输出：bab
思路：中心扩展。

```python
class Solution:
    def longestPalindrome(self, text: str) -> str:
        def expand(left, right):
            while left >= 0 and right < len(text) and text[left] == text[right]:
                left -= 1
                right += 1
            return text[left+1:right]
        ans = ""
        for index in range(len(text)):
            ans = max(ans, expand(index, index), expand(index, index+1), key=len)
        return ans
```

### 20 有效的括号
题目：给定只包含括号的字符串 `s`，判断括号是否有效匹配。
示例：输入：s = ()[]{}；输出：True
思路：栈匹配。

```python
class Solution:
    def isValid(self, text: str) -> bool:
        stack = []
        mp = {')':'(', ']':'[', '}':'{'}
        for ch in text:
            if ch in mp:
                if not stack or stack.pop() != mp[ch]:
                    return False
            else:
                stack.append(ch)
        return not stack
```

### 28 找出字符串中第一个匹配的下标
题目：给定字符串 `haystack` 和 `needle`，返回 `needle` 在 `haystack` 中第一次出现的位置，不存在返回 -1。
示例：输入：haystack = sadbutsad, needle = sad；输出：0
思路：KMP 预处理前缀表。

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle == "":
            return 0
        length = len(needle)
        lps = [0] * length
        index2 = 0
        for index in range(1, length):
            while index2 > 0 and needle[index] != needle[index2]:
                index2 = lps[index2-1]
            if needle[index] == needle[index2]:
                index2 += 1
                lps[index] = index2
        index2 = 0
        for index, ch in enumerate(haystack):
            while index2 > 0 and ch != needle[index2]:
                index2 = lps[index2-1]
            if ch == needle[index2]:
                index2 += 1
                if index2 == length:
                    return index - length + 1
        return -1
```

### 38 外观数列
题目：给定整数 n，返回外观数列的第 n 项。
示例：输入：n = 4；输出：1211
思路：模拟读数写数。

```python
class Solution:
    def countAndSay(self, length: int) -> str:
        text = "1"
        for _ in range(length - 1):
            index = 0
            out = []
            while index < len(text):
                index2 = index
                while index2 < len(text) and text[index2] == text[index]:
                    index2 += 1
                out.append(str(index2 - index))
                out.append(text[index])
                index = index2
            text = "".join(out)
        return text
```

### 49 字母异位词分组
题目：给定字符串数组，将字母异位词分组后返回。
示例：输入：strs = [eat,tea,tan,ate,nat,bat]；输出：[[eat,tea,ate],[tan,nat],[bat]]
思路：排序字符串作为键。

```python
from typing import List
from collections import defaultdict

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        mp = defaultdict(list)
        for text in strs:
            key = "".join(sorted(text))
            mp[key].append(text)
        return list(mp.values())
```

### 76 最小覆盖子串
题目：给定字符串 `s` 和 `t`，找出 `s` 中包含 `t` 所有字符的最小子串。
示例：输入：s = ADOBECODEBANC, t = ABC；输出：BANC
思路：滑动窗口统计需求。

```python
from collections import Counter

class Solution:
    def minWindow(self, text: str, temp: str) -> str:
        need = Counter(temp)
        missing = len(temp)
        left = start = 0
        best = float("inf")
        for right, ch in enumerate(text):
            if need[ch] > 0:
                missing -= 1
            need[ch] -= 1
            while missing == 0:
                if right - left + 1 < best:
                    best = right - left + 1
                    start = left
                need[text[left]] += 1
                if need[text[left]] > 0:
                    missing += 1
                left += 1
        return "" if best == float("inf") else text[start:start+best]
```

### 91 解码方法
题目：给定仅包含数字的字符串，按 1-26 映射到 A-Z，返回解码方法总数。
示例：输入：s = 226；输出：3
思路：线性 DP。

```python
class Solution:
    def numDecodings(self, text: str) -> int:
        if not text or text[0] == '0':
            return 0
        prev2, prev1 = 1, 1
        for index in range(1, len(text)):
            cur = 0
            if text[index] != '0':
                cur += prev1
            two = int(text[index-1:index+1])
            if 10 <= two <= 26:
                cur += prev2
            prev2, prev1 = prev1, cur
        return prev1
```

### 125 验证回文串
题目：给定字符串 `s`，只考虑字母和数字并忽略大小写，判断是否为回文。
示例：输入：s = A man, a plan, a canal: Panama；输出：True
思路：双指针跳过非字母数字。

```python
class Solution:
    def isPalindrome(self, text: str) -> bool:
        left, right = 0, len(text) - 1
        while left < right:
            while left < right and not text[left].isalnum():
                left += 1
            while left < right and not text[right].isalnum():
                right -= 1
            if text[left].lower() != text[right].lower():
                return False
            left += 1
            right -= 1
        return True
```

### 242 有效的字母异位词
题目：给定两个字符串 `s` 和 `t`，判断 `t` 是否为 `s` 的字母异位词。
示例：输入：s = anagram, t = nagaram；输出：True
思路：计数比较。

```python
from collections import Counter

class Solution:
    def isAnagram(self, text: str, temp: str) -> bool:
        return Counter(text) == Counter(temp)
```

## 哈希 & 位运算

### 136 只出现一次的数字
题目：给定非空整数数组，除一个元素只出现一次外，其余都出现两次，找出只出现一次的元素。
示例：输入：nums = [4,1,2,1,2]；输出：4
思路：异或抵消。

```python
from typing import List

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        value = 0
        for length in nums:
            value ^= length
        return value
```

### 137 只出现一次的数字 II
题目：给定整数数组，除一个元素只出现一次外，其余都出现三次，找出只出现一次的元素。
示例：输入：nums = [2,2,3,2]；输出：3
思路：统计每一位 1 的个数取模。

```python
from typing import List

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        res = 0
        for second in range(32):
            text = 0
            for value in nums:
                text += (value >> second) & 1
            if text % 3:
                res |= (1 << second)
        if res >= 2**31:
            res -= 2**32
        return res
```

### 191 位1的个数
题目：给定无符号整数 `n`，返回其二进制表示中 1 的个数。
示例：输入：n = 11；输出：3
思路：n & (n-1) 去掉最低位 1。

```python
class Solution:
    def hammingWeight(self, length: int) -> int:
        cnt = 0
        while length:
            length &= length - 1
            cnt += 1
        return cnt
```

### 260 只出现一次的数字 III
题目：给定整数数组，恰有两个元素只出现一次，其余都出现两次，返回这两个元素。
示例：输入：nums = [1,2,1,3,2,5]；输出：[3,5]
思路：整体异或得到两数差异位，按该位分组异或。

```python
from typing import List

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        value = 0
        for length in nums:
            value ^= length
        lowbit = value & -value
        first = second = 0
        for length in nums:
            if length & lowbit:
                first ^= length
            else:
                second ^= length
        return [first, second]
```

### 338 比特位计数
题目：给定整数 `n`，返回 `0..n` 每个数的二进制中 1 的个数数组。
示例：输入：n = 5；输出：[0,1,1,2,1,2]
思路：dp[i] = dp[i>>1] + (i&1)。

```python
from typing import List

class Solution:
    def countBits(self, length: int) -> List[int]:
        dp = [0] * (length + 1)
        for index in range(1, length + 1):
            dp[index] = dp[index >> 1] + (index & 1)
        return dp
```

## 栈 / 队列 / 堆

### 155 最小栈
题目：设计一个支持 push、pop、top、getMin 的栈，getMin 在常数时间内返回最小值。
示例：输入：push -2, push 0, push -3, getMin；输出：-3
思路：辅助栈同步维护最小值。

```python
class MinStack:
    def __init__(self):
        self.text = []
        self.min_s = []

    def push(self, val: int) -> None:
        self.text.append(val)
        if not self.min_s or val <= self.min_s[-1]:
            self.min_s.append(val)

    def pop(self) -> None:
        if self.text.pop() == self.min_s[-1]:
            self.min_s.pop()

    def top(self) -> int:
        return self.text[-1]

    def getMin(self) -> int:
        return self.min_s[-1]
```

### 232 用栈实现队列
题目：使用两个栈实现队列，支持 push、pop、peek、empty。
示例：输入：push 1, push 2, peek, pop；输出：1, 1
思路：两个栈进出。

```python
class MyQueue:
    def __init__(self):
        self.in_s = []
        self.out_s = []

    def push(self, value: int) -> None:
        self.in_s.append(value)

    def _move(self):
        if not self.out_s:
            while self.in_s:
                self.out_s.append(self.in_s.pop())

    def pop(self) -> int:
        self._move()
        return self.out_s.pop()

    def peek(self) -> int:
        self._move()
        return self.out_s[-1]

    def empty(self) -> bool:
        return not self.in_s and not self.out_s
```

### 239 滑动窗口最大值
题目：给定数组 `nums` 和窗口大小 `k`，返回每个窗口中的最大值。
示例：输入：nums = [1,3,-1,-3,5,3,6,7], k = 3；输出：[3,3,5,5,6,7]
思路：单调队列存索引。

```python
from typing import List
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums: List[int], key: int) -> List[int]:
        queue = deque()
        res = []
        for index, value in enumerate(nums):
            while queue and nums[queue[-1]] <= value:
                queue.pop()
            queue.append(index)
            if queue[0] <= index - key:
                queue.popleft()
            if index >= key - 1:
                res.append(nums[queue[0]])
        return res
```

### 295 数据流的中位数
题目：设计数据结构支持添加数字并返回当前数据流的中位数。
示例：输入：add 1, add 2, findMedian, add 3, findMedian；输出：1.5, 2
思路：大小根堆平衡。

```python
import heapq

class MedianFinder:
    def __init__(self):
        self.small = []
        self.large = []

    def addNum(self, num: int) -> None:
        if not self.small or num <= -self.small[0]:
            heapq.heappush(self.small, -num)
        else:
            heapq.heappush(self.large, num)
        if len(self.small) > len(self.large) + 1:
            heapq.heappush(self.large, -heapq.heappop(self.small))
        if len(self.large) > len(self.small):
            heapq.heappush(self.small, -heapq.heappop(self.large))

    def findMedian(self) -> float:
        if len(self.small) > len(self.large):
            return float(-self.small[0])
        return (-self.small[0] + self.large[0]) / 2.0
```

### 739 每日温度
题目：给定每日温度数组，返回每一天需等待多少天温度更高，若无更高则为 0。
示例：输入：temperatures = [73,74,75,71,69,72,76,73]；输出：[1,1,4,2,1,1,0,0]
思路：单调栈存索引。

```python
from typing import List

class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        res = [0] * len(temperatures)
        stack = []
        for index, temp in enumerate(temperatures):
            while stack and temperatures[stack[-1]] < temp:
                index2 = stack.pop()
                res[index2] = index - index2
            stack.append(index)
        return res
```

## 二叉树 / 二叉搜索树

### 94 二叉树中序遍历
题目：给定二叉树根节点，返回其中序遍历结果。
示例：输入：root = [1,null,2,3]；输出：[1,3,2]
思路：递归遍历。

```python
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def dfs(node):
            if not node:
                return
            dfs(node.left)
            res.append(node.val)
            dfs(node.right)
        dfs(root)
        return res
```

### 98 验证二叉搜索树
题目：给定二叉树根节点，判断其是否为有效二叉搜索树。
示例：输入：root = [2,1,3]；输出：True
思路：中序递增。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        prev = None
        def dfs(node):
            nonlocal prev
            if not node:
                return True
            if not dfs(node.left):
                return False
            if prev is not None and node.val <= prev:
                return False
            prev = node.val
            return dfs(node.right)
        return dfs(root)
```

### 100 相同的树
题目：给定两棵二叉树，判断它们是否结构相同且节点值相等。
示例：输入：p = [1,2,3], q = [1,2,3]；输出：True
思路：递归比较。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSameTree(self, ptr: Optional[TreeNode], queue: Optional[TreeNode]) -> bool:
        if not ptr or not queue:
            return ptr == queue
        if ptr.val != queue.val:
            return False
        return self.isSameTree(ptr.left, queue.left) and self.isSameTree(ptr.right, queue.right)
```

### 101 对称二叉树
题目：给定二叉树根节点，判断其是否左右对称。
示例：输入：root = [1,2,2,3,4,4,3]；输出：True
思路：递归比较镜像子树。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def mirror(first, second):
            if not first or not second:
                return first == second
            if first.val != second.val:
                return False
            return mirror(first.left, second.right) and mirror(first.right, second.left)
        return mirror(root, root)
```

### 102 二叉树层序遍历
题目：给定二叉树根节点，返回其层序遍历结果。
示例：输入：root = [3,9,20,null,null,15,7]；输出：[[3],[9,20],[15,7]]
思路：BFS 队列。

```python
from typing import List, Optional
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        res = []
        queue = deque([root])
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res
```

### 104 二叉树最大深度
题目：给定二叉树根节点，返回其最大深度。
示例：输入：root = [3,9,20,null,null,15,7]；输出：3
思路：DFS 深度。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```

### 105 从前序与中序构造二叉树
题目：给定前序和中序遍历数组，构造并返回二叉树。
示例：输入：pre = [3,9,20,15,7], in = [9,3,15,20,7]；输出：对应二叉树
思路：前序定根，中序分左右。

```python
from typing import Optional, List

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        index = {value:index for index, value in enumerate(inorder)}
        it = iter(preorder)
        def helper(left, right):
            if left > right:
                return None
            root_val = next(it)
            mid = index[root_val]
            root = TreeNode(root_val)
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root
        return helper(0, len(inorder) - 1)
```

### 108 将有序数组转为 BST
题目：给定升序数组，构造高度平衡的二叉搜索树并返回。
示例：输入：nums = [-10,-3,0,5,9]；输出：一棵平衡 BST
思路：二分选中点为根。

```python
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def build(left, right):
            if left > right:
                return None
            mid = (left + right) // 2
            root = TreeNode(nums[mid])
            root.left = build(left, mid - 1)
            root.right = build(mid + 1, right)
            return root
        return build(0, len(nums) - 1)
```

### 110 平衡二叉树
题目：给定二叉树根节点，判断其是否为高度平衡二叉树。
示例：输入：root = [3,9,20,null,null,15,7]；输出：True
思路：自底向上返回高度，失衡返回 -1。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def height(node):
            if not node:
                return 0
            lh = height(node.left)
            if lh == -1:
                return -1
            rh = height(node.right)
            if rh == -1 or abs(lh - rh) > 1:
                return -1
            return 1 + max(lh, rh)
        return height(root) != -1
```

### 124 二叉树最大路径和
题目：给定二叉树，路径可从任意节点到任意节点，返回最大路径和。
示例：输入：root = [-10,9,20,null,null,15,7]；输出：42
思路：后序返回单边最大，更新全局答案。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        ans = -10**18
        def dfs(node):
            nonlocal ans
            if not node:
                return 0
            left = max(dfs(node.left), 0)
            right = max(dfs(node.right), 0)
            ans = max(ans, node.val + left + right)
            return node.val + max(left, right)
        dfs(root)
        return ans
```

### 144 前序遍历
题目：给定二叉树根节点，返回其前序遍历结果。
示例：输入：root = [1,null,2,3]；输出：[1,2,3]
思路：迭代栈。

```python
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        res = []
        stack = [root]
        while stack:
            node = stack.pop()
            res.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return res
```

### 145 后序遍历
题目：给定二叉树根节点，返回其后序遍历结果。
示例：输入：root = [1,null,2,3]；输出：[3,2,1]
思路：迭代，先根右左再反转。

```python
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        res = []
        stack = [root]
        while stack:
            node = stack.pop()
            res.append(node.val)
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        return res[::-1]
```

### 199 二叉树右视图
题目：给定二叉树根节点，返回从右侧看到的节点值。
示例：输入：root = [1,2,3,null,5,null,4]；输出：[1,3,4]
思路：层序最后一个节点。

```python
from typing import List, Optional
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        res = []
        queue = deque([root])
        while queue:
            size = len(queue)
            for index in range(size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                if index == size - 1:
                    res.append(node.val)
        return res
```

### 226 翻转二叉树
题目：给定二叉树根节点，将其左右子树交换并返回根节点。
示例：输入：root = [4,2,7,1,3,6,9]；输出：[4,7,2,9,6,3,1]
思路：递归交换左右。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)
        return root
```

### 236 二叉树最近公共祖先
题目：给定二叉树与两个节点 p、q，返回它们的最近公共祖先。
示例：输入：root = [3,5,1,6,2,0,8], p = 5, q = 1；输出：3
思路：递归返回命中节点。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', ptr: 'TreeNode', queue: 'TreeNode') -> 'TreeNode':
        if not root or root == ptr or root == queue:
            return root
        left = self.lowestCommonAncestor(root.left, ptr, queue)
        right = self.lowestCommonAncestor(root.right, ptr, queue)
        if left and right:
            return root
        return left or right
```

### 297 二叉树序列化与反序列化
题目：设计序列化与反序列化二叉树的方法。
示例：输入：root = [1,2,3,null,null,4,5]；输出：可序列化并还原同树
思路：前序 DFS 序列化，反序列化按序构建。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Codec:
    def serialize(self, root: Optional[TreeNode]) -> str:
        res = []
        def dfs(node):
            if not node:
                res.append('#')
                return
            res.append(str(node.val))
            dfs(node.left)
            dfs(node.right)
        dfs(root)
        return ",".join(res)

    def deserialize(self, data: str) -> Optional[TreeNode]:
        vals = iter(data.split(','))
        def dfs():
            value = next(vals)
            if value == '#':
                return None
            node = TreeNode(int(value))
            node.left = dfs()
            node.right = dfs()
            return node
        return dfs()
```

## 回溯 / DFS / BFS

### 17 电话号码的字母组合
题目：给定数字字符串 `digits`（2-9），返回所有可能的字母组合。
示例：输入：digits = 23；输出：[ad,ae,af,bd,be,bf,cd,ce,cf]
思路：回溯枚举。

```python
from typing import List

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        mp = {
            '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
            '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
        }
        res = []
        def dfs(index, path):
            if index == len(digits):
                res.append("".join(path))
                return
            for ch in mp[digits[index]]:
                path.append(ch)
                dfs(index + 1, path)
                path.pop()
        dfs(0, [])
        return res
```

### 22 括号生成
题目：给定整数 n，生成所有有效的 n 对括号组合。
示例：输入：n = 3；输出：[((())),(()()),(())(),()(()),()()()]
思路：回溯控制左右括号数量。

```python
from typing import List

class Solution:
    def generateParenthesis(self, length: int) -> List[str]:
        res = []
        def dfs(left, right, path):
            if len(path) == 2 * length:
                res.append("".join(path))
                return
            if left < length:
                path.append('(')
                dfs(left + 1, right, path)
                path.pop()
            if right < left:
                path.append(')')
                dfs(left, right + 1, path)
                path.pop()
        dfs(0, 0, [])
        return res
```

### 46 全排列
题目：给定不含重复数字的数组，返回所有可能的全排列。
示例：输入：nums = [1,2,3]；输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
思路：回溯+使用标记。

```python
from typing import List

class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        used = [False] * len(nums)
        def dfs(path):
            if len(path) == len(nums):
                res.append(path[:])
                return
            for index in range(len(nums)):
                if used[index]:
                    continue
                used[index] = True
                path.append(nums[index])
                dfs(path)
                path.pop()
                used[index] = False
        dfs([])
        return res
```

### 47 全排列 II
题目：给定可能含重复数字的数组，返回所有不重复的全排列。
示例：输入：nums = [1,1,2]；输出：[[1,1,2],[1,2,1],[2,1,1]]
思路：排序后去重。

```python
from typing import List

class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        used = [False] * len(nums)
        def dfs(path):
            if len(path) == len(nums):
                res.append(path[:])
                return
            for index in range(len(nums)):
                if used[index]:
                    continue
                if index > 0 and nums[index] == nums[index-1] and not used[index-1]:
                    continue
                used[index] = True
                path.append(nums[index])
                dfs(path)
                path.pop()
                used[index] = False
        dfs([])
        return res
```

### 78 子集
题目：给定整数数组 `nums`，返回其所有子集（幂集）。
示例：输入：nums = [1,2]；输出：[[],[1],[2],[1,2]]
思路：回溯枚举选/不选。

```python
from typing import List

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        def dfs(index, path):
            if index == len(nums):
                res.append(path[:])
                return
            dfs(index + 1, path)
            path.append(nums[index])
            dfs(index + 1, path)
            path.pop()
        dfs(0, [])
        return res
```

### 79 单词搜索
题目：给定字母网格和单词，判断是否能通过上下左右相邻字母构成该单词。
示例：输入：board = [[A,B,C],[D,E,F]], word = ABE；输出：True
思路：DFS 回溯标记访问。

```python
from typing import List

class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        rows, cols = len(board), len(board[0])
        def dfs(row, col, key):
            if key == len(word):
                return True
            if row < 0 or row >= rows or col < 0 or col >= cols or board[row][col] != word[key]:
                return False
            tmp = board[row][col]
            board[row][col] = '#'
            ok = dfs(row+1, col, key+1) or dfs(row-1, col, key+1) or dfs(row, col+1, key+1) or dfs(row, col-1, key+1)
            board[row][col] = tmp
            return ok
        for row in range(rows):
            for col in range(cols):
                if dfs(row, col, 0):
                    return True
        return False
```

### 200 岛屿数量
题目：给定由 '1' 和 '0' 组成的网格，统计岛屿数量（上下左右相连为一岛）。
示例：输入：grid = [[1,1,0],[1,0,0],[0,0,1]]；输出：2
思路：DFS 或 BFS 遍历连通块。

```python
from typing import List

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        rows, cols = len(grid), len(grid[0])
        def dfs(row, col):
            if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != '1':
                return
            grid[row][col] = '0'
            dfs(row+1, col); dfs(row-1, col); dfs(row, col+1); dfs(row, col-1)
        cnt = 0
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == '1':
                    cnt += 1
                    dfs(row, col)
        return cnt
```

### 301 删除无效的括号
题目：给定字符串 `s`，删除最少数量的括号使其有效，返回所有可能结果。
示例：输入：s = ()())()；输出：[()()(),(())()]
思路：BFS 逐层删除，首次找到即最短。

```python
from typing import List
from collections import deque

class Solution:
    def removeInvalidParentheses(self, text: str) -> List[str]:
        def valid(temp):
            bal = 0
            for ch in temp:
                if ch == '(':
                    bal += 1
                elif ch == ')':
                    bal -= 1
                    if bal < 0:
                        return False
            return bal == 0
        res = []
        visited = {text}
        queue = deque([text])
        found = False
        while queue:
            temp = queue.popleft()
            if valid(temp):
                res.append(temp)
                found = True
            if found:
                continue
            for index in range(len(temp)):
                if temp[index] not in "()":
                    continue
                nt = temp[:index] + temp[index+1:]
                if nt not in visited:
                    visited.add(nt)
                    queue.append(nt)
        return res
```

## 动态规划（简单 → 困难）

### 70 爬楼梯
题目：给定 n 阶楼梯，每次走 1 或 2 阶，求不同的爬法总数。
示例：输入：n = 3；输出：3
思路：斐波那契 DP。

```python
class Solution:
    def climbStairs(self, length: int) -> int:
        first, second = 1, 1
        for _ in range(length):
            first, second = second, first + second
        return first
```

### 118 杨辉三角
题目：给定 `numRows`，生成前 `numRows` 行杨辉三角。
示例：输入：numRows = 5；输出：[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
思路：逐行生成。

```python
from typing import List

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        for index in range(numRows):
            row = [1] * (index + 1)
            for index2 in range(1, index):
                row[index2] = res[index-1][index2-1] + res[index-1][index2]
            res.append(row)
        return res
```

### 121 买卖股票最佳时机
题目：给定每日股价数组，只允许一次买卖，返回最大利润。
示例：输入：prices = [7,1,5,3,6,4]；输出：5
思路：维护历史最低价。

```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        low = 10**9
        ans = 0
        for ptr in prices:
            low = min(low, ptr)
            ans = max(ans, ptr - low)
        return ans
```

### 122 买卖股票最佳时机 II
题目：给定每日股价数组，可进行多次交易（同一时间只能持有一股），返回最大利润。
示例：输入：prices = [7,1,5,3,6,4]；输出：7
思路：累计所有上升差价。

```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for index in range(1, len(prices)):
            if prices[index] > prices[index-1]:
                ans += prices[index] - prices[index-1]
        return ans
```

### 198 打家劫舍
题目：给定非负整数数组表示每间房的金额，相邻房不能同时偷，返回最大金额。
示例：输入：nums = [1,2,3,1]；输出：4
思路：DP 滚动。

```python
from typing import List

class Solution:
    def rob(self, nums: List[int]) -> int:
        prev2, prev1 = 0, 0
        for value in nums:
            prev2, prev1 = prev1, max(prev1, prev2 + value)
        return prev1
```

### 213 打家劫舍 II
题目：房屋围成一圈，首尾相邻，其余同打家劫舍，返回最大可偷金额。
示例：输入：nums = [2,3,2]；输出：3
思路：环拆两段取最大。

```python
from typing import List

class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        def rob_line(arr):
            prev2, prev1 = 0, 0
            for value in arr:
                prev2, prev1 = prev1, max(prev1, prev2 + value)
            return prev1
        return max(rob_line(nums[:-1]), rob_line(nums[1:]))
```

### 139 单词拆分
题目：给定字符串 `s` 与词典 `wordDict`，判断 `s` 是否能被拆分为字典单词。
示例：输入：s = leetcode, wordDict = [leet,code]；输出：True
思路：DP + 词典集合。

```python
from typing import List

class Solution:
    def wordBreak(self, text: str, wordDict: List[str]) -> bool:
        word = set(wordDict)
        dp = [False] * (len(text) + 1)
        dp[0] = True
        for index in range(1, len(text) + 1):
            for index2 in range(index):
                if dp[index2] and text[index2:index] in word:
                    dp[index] = True
                    break
        return dp[-1]
```

### 300 最长递增子序列
题目：给定整数数组，返回最长严格递增子序列长度。
示例：输入：nums = [10,9,2,5,3,7,101,18]；输出：4
思路：贪心+二分维护尾数组。

```python
from typing import List
import bisect

class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        tails = []
        for value in nums:
            index = bisect.bisect_left(tails, value)
            if index == len(tails):
                tails.append(value)
            else:
                tails[index] = value
        return len(tails)
```

### 322 零钱兑换
题目：给定硬币面额数组和金额 `amount`，返回凑成金额的最少硬币数，无法凑成返回 -1。
示例：输入：coins = [1,2,5], amount = 11；输出：3
思路：完全背包最小值。

```python
from typing import List

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [10**9] * (amount + 1)
        dp[0] = 0
        for first in range(1, amount + 1):
            for coin in coins:
                if coin <= first:
                    dp[first] = min(dp[first], dp[first - coin] + 1)
        return -1 if dp[amount] == 10**9 else dp[amount]
```

### 416 分割等和子集
题目：给定非空数组，判断能否分成两个子集使元素和相等。
示例：输入：nums = [1,5,11,5]；输出：True
思路：0-1 背包。

```python
from typing import List

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        text = sum(nums)
        if text % 2:
            return False
        target = text // 2
        dp = [False] * (target + 1)
        dp[0] = True
        for value in nums:
            for temp in range(target, value - 1, -1):
                dp[temp] = dp[temp] or dp[temp - value]
        return dp[target]
```

### 518 零钱兑换 II
题目：给定硬币面额数组和金额 `amount`，返回凑成金额的组合数（顺序无关）。
示例：输入：coins = [1,2,5], amount = 5；输出：4
思路：组合数，外层遍历硬币。

```python
from typing import List

class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount + 1)
        dp[0] = 1
        for coin in coins:
            for first in range(coin, amount + 1):
                dp[first] += dp[first - coin]
        return dp[amount]
```

### 64 最小路径和
题目：给定 m×n 网格，每次只能向右或向下移动，返回从左上到右下的最小路径和。
示例：输入：grid = [[1,3,1],[1,5,1],[4,2,1]]；输出：7
思路：网格 DP。

```python
from typing import List

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        dp = [10**9] * cols
        dp[0] = 0
        for row in range(rows):
            dp[0] += grid[row][0]
            for col in range(1, cols):
                dp[col] = min(dp[col], dp[col-1]) + grid[row][col]
        return dp[-1]
```

### 72 编辑距离
题目：给定两个字符串，返回将 word1 转换为 word2 的最少编辑次数。
示例：输入：word1 = horse, word2 = ros；输出：3
思路：二维 DP 变换。

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        mid, length = len(word1), len(word2)
        dp = [[0]*(length+1) for _ in range(mid+1)]
        for index in range(mid+1):
            dp[index][0] = index
        for index2 in range(length+1):
            dp[0][index2] = index2
        for index in range(1, mid+1):
            for index2 in range(1, length+1):
                if word1[index-1] == word2[index2-1]:
                    dp[index][index2] = dp[index-1][index2-1]
                else:
                    dp[index][index2] = 1 + min(dp[index-1][index2], dp[index][index2-1], dp[index-1][index2-1])
        return dp[mid][length]
```

### 221 最大正方形
题目：给定只包含 0/1 的矩阵，返回只包含 1 的最大正方形面积。
示例：输入：matrix = [[1,0],[1,1]]；输出：1
思路：dp[i][j] 为右下角正方形边长。

```python
from typing import List

class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix:
            return 0
        rows, cols = len(matrix), len(matrix[0])
        dp = [0] * (cols + 1)
        ans = 0
        for row in range(1, rows + 1):
            prev = 0
            for col in range(1, cols + 1):
                temp = dp[col]
                if matrix[row-1][col-1] == '1':
                    dp[col] = min(dp[col], dp[col-1], prev) + 1
                    ans = max(ans, dp[col])
                else:
                    dp[col] = 0
                prev = temp
        return ans * ans
```

### 279 完全平方数
题目：给定整数 n，返回和为 n 的完全平方数的最少数量。
示例：输入：n = 12；输出：3（4+4+4）
思路：完全背包最少数。

```python
class Solution:
    def numSquares(self, length: int) -> int:
        dp = [10**9] * (length + 1)
        dp[0] = 0
        index = 1
        while index * index <= length:
            sq = index * index
            for index2 in range(sq, length + 1):
                dp[index2] = min(dp[index2], dp[index2 - sq] + 1)
            index += 1
        return dp[length]
```

### 309 最佳买卖股票时机含冷冻期
题目：给定每日股价，可多次交易但卖出后有一天冷冻期，返回最大利润。
示例：输入：prices = [1,2,3,0,2]；输出：3
思路：状态机 DP。

```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        hold = -10**9
        sold = 0
        rest = 0
        for ptr in prices:
            prev_sold = sold
            sold = hold + ptr
            hold = max(hold, rest - ptr)
            rest = max(rest, prev_sold)
        return max(sold, rest)
```

### 337 打家劫舍 III
题目：给定二叉树，每个节点为房屋金额，相邻节点不能同时偷，返回最大金额。
示例：输入：root = [3,2,3,null,3,null,1]；输出：7
思路：树形 DP 返回抢/不抢。

```python
from typing import Optional, Tuple

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        def dfs(node) -> Tuple[int, int]:
            if not node:
                return (0, 0)
            l0, l1 = dfs(node.left)
            r0, r1 = dfs(node.right)
            rob = node.val + l0 + r0
            skip = max(l0, l1) + max(r0, r1)
            return (skip, rob)
        skip, rob = dfs(root)
        return max(skip, rob)
```

## 贪心

### 406 根据身高重建队列
题目：给定 (h,k) 队列信息，h 为身高，k 为前面身高 ≥ h 的人数，重建队列。
示例：输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]；输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
思路：按身高降序、k 升序插入。

```python
from typing import List

class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda value: (-value[0], value[1]))
        res = []
        for person in people:
            res.insert(person[1], person)
        return res
```

## 图论 / 拓扑 / 并查集 / 最短路

### 207 课程表
题目：给定课程总数和先修关系，判断能否完成所有课程。
示例：输入：numCourses = 2, prerequisites = [[1,0]]；输出：True
思路：拓扑排序判环。

```python
from typing import List
from collections import deque

class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = [[] for _ in range(numCourses)]
        indeg = [0] * numCourses
        for course, prereq in prerequisites:
            graph[prereq].append(course)
            indeg[course] += 1
        queue = deque([index for index in range(numCourses) if indeg[index] == 0])
        seen = 0
        while queue:
            node = queue.popleft()
            seen += 1
            for value in graph[node]:
                indeg[value] -= 1
                if indeg[value] == 0:
                    queue.append(value)
        return seen == numCourses
```

### 210 课程表 II
题目：给定课程总数和先修关系，返回一种可行的修课顺序，否则返回空数组。
示例：输入：numCourses = 2, prerequisites = [[1,0]]；输出：[0,1]
思路：拓扑排序输出顺序。

```python
from typing import List
from collections import deque

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(numCourses)]
        indeg = [0] * numCourses
        for course, prereq in prerequisites:
            graph[prereq].append(course)
            indeg[course] += 1
        queue = deque([index for index in range(numCourses) if indeg[index] == 0])
        res = []
        while queue:
            node = queue.popleft()
            res.append(node)
            for value in graph[node]:
                indeg[value] -= 1
                if indeg[value] == 0:
                    queue.append(value)
        return res if len(res) == numCourses else []
```

### 684 冗余连接
题目：给定一棵树加一条边形成的图，找到可以移除的那条多余边。
示例：输入：edges = [[1,2],[1,3],[2,3]]；输出：[2,3]
思路：并查集，出现环的边即答案。

```python
from typing import List

class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        parent = {}
        def find(value):
            parent.setdefault(value, value)
            if parent[value] != value:
                parent[value] = find(parent[value])
            return parent[value]
        def union(node_u, node_v):
            pa, pb = find(node_u), find(node_v)
            if pa == pb:
                return False
            parent[pa] = pb
            return True
        for node_u, node_v in edges:
            if not union(node_u, node_v):
                return [node_u, node_v]
        return []
```

### 785 判断二分图
题目：给定无向图，判断是否可以将节点分成两组使每条边两端节点属于不同组。
示例：输入：graph = [[1,3],[0,2],[1,3],[0,2]]；输出：True
思路：DFS 染色。

```python
from typing import List

class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        length = len(graph)
        color = [0] * length
        def dfs(node, value):
            color[node] = value
            for value in graph[node]:
                if color[value] == value:
                    return False
                if color[value] == 0 and not dfs(value, -value):
                    return False
            return True
        for index in range(length):
            if color[index] == 0 and not dfs(index, 1):
                return False
        return True
```

### 127 单词接龙
题目：给定 beginWord、endWord 和字典，返回从 beginWord 变到 endWord 的最短转换序列长度。
示例：输入：beginWord = hit, endWord = cog, wordList = [hot,dot,dog,lot,log,cog]；输出：5
思路：双向 BFS。

```python
from typing import List

class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordSet = set(wordList)
        if endWord not in wordSet:
            return 0
        begin, end = {beginWord}, {endWord}
        step = 1
        while begin and end:
            if len(begin) > len(end):
                begin, end = end, begin
            nxt = set()
            for word in begin:
                for index in range(len(word)):
                    for ch in "abcdefghijklmnopqrstuvwxyz":
                        nw = word[:index] + ch + word[index+1:]
                        if nw in end:
                            return step + 1
                        if nw in wordSet:
                            wordSet.remove(nw)
                            nxt.add(nw)
            begin = nxt
            step += 1
        return 0
```

### 994 腐烂的橘子
题目：给定网格 0/1/2 表示空/新鲜/腐烂，腐烂会扩散，返回使所有新鲜腐烂的最小分钟数。
示例：输入：grid = [[2,1,1],[1,1,0],[0,1,1]]；输出：4
思路：多源 BFS。

```python
from typing import List
from collections import deque

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        queue = deque()
        fresh = 0
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == 2:
                    queue.append((row, col))
                elif grid[row][col] == 1:
                    fresh += 1
        minutes = 0
        dirs = [(1,0),(-1,0),(0,1),(0,-1)]
        while queue and fresh:
            for _ in range(len(queue)):
                row, col = queue.popleft()
                for di, dj in dirs:
                    ni, nj = row + di, col + dj
                    if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] == 1:
                        grid[ni][nj] = 2
                        fresh -= 1
                        queue.append((ni, nj))
            minutes += 1
        return minutes if fresh == 0 else -1
```

## 二分 & 数学

### 69 x 的平方根
题目：给定非负整数 x，计算并返回其平方根的整数部分。
示例：输入：x = 8；输出：2
思路：二分取整。

```python
class Solution:
    def mySqrt(self, value: int) -> int:
        left, right = 0, value
        while left <= right:
            mid = (left + right) // 2
            if mid * mid <= value:
                left = mid + 1
            else:
                right = mid - 1
        return right
```

### 50 Pow(x, n)
题目：实现 `pow(x, n)`，计算 x 的 n 次幂。
示例：输入：x = 2.0, n = 10；输出：1024.0
????? `pow(x, n)`??? x ? n ???
??????x = 2.0, n = 10????1024.0
思路：快速幂。

```python
class Solution:
    def myPow(self, value: float, length: int) -> float:
        if length == 0:
            return 1.0
        if length < 0:
            value, length = 1 / value, -length
        res = 1.0
        while length:
            if length & 1:
                res *= value
            value *= value
            length >>= 1
        return res
```

### 172 阶乘后的零
题目：给定整数 n，返回 n! 末尾零的个数。
示例：输入：n = 25；输出：6
思路：统计因子 5 的数量。

```python
class Solution:
    def trailingZeroes(self, length: int) -> int:
        ans = 0
        while length:
            length //= 5
            ans += length
        return ans
```

### 367 有效的完全平方数
题目：给定正整数 `num`，判断它是否为完全平方数。
示例：输入：num = 16；输出：True
思路：二分。

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left, right = 1, num
        while left <= right:
            mid = (left + right) // 2
            sq = mid * mid
            if sq == num:
                return True
            if sq < num:
                left = mid + 1
            else:
                right = mid - 1
        return num == 1
```

## 滑动窗口 / 双指针

### 438 找到字符串中所有字母异位词
题目：给定字符串 `s` 与 `p`，找出 `s` 中所有 `p` 的异位词起始索引。
示例：输入：s = cbaebabacd, p = abc；输出：[0,6]
思路：固定窗口计数比较。

```python
from typing import List
from collections import Counter

class Solution:
    def findAnagrams(self, text: str, ptr: str) -> List[int]:
        if len(ptr) > len(text):
            return []
        res = []
        need = Counter(ptr)
        window = Counter(text[:len(ptr)])
        if window == need:
            res.append(0)
        for index in range(len(ptr), len(text)):
            window[text[index]] += 1
            window[text[index - len(ptr)]] -= 1
            if window[text[index - len(ptr)]] == 0:
                del window[text[index - len(ptr)]]
            if window == need:
                res.append(index - len(ptr) + 1)
        return res
```

## Trie / 字符串匹配

### 208 实现 Trie
题目：设计并实现 Trie（前缀树），支持插入、查找、前缀匹配。
示例：输入：insert apple, search apple, search app, startsWith app；输出：True, False, True
思路：字典树节点记录 children 与结尾标记。

```python
class Trie:
    def __init__(self):
        self.children = {}
        self.end = False

    def insert(self, word: str) -> None:
        node = self
        for ch in word:
            node = node.children.setdefault(ch, Trie())
        node.end = True

    def search(self, word: str) -> bool:
        node = self
        for ch in word:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return node.end

    def startsWith(self, prefix: str) -> bool:
        node = self
        for ch in prefix:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return True
```

### 212 单词搜索 II
题目：给定字符网格和单词列表，找出所有可以在网格中通过相邻字母拼出的单词。
示例：输入：board = [[o,a,a],[e,t,a],[i,h,k]], words = [oath,eat,rain]；输出：[oath,eat]
思路：Trie + DFS 剪枝。

```python
from typing import List

class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = None

class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        root = TrieNode()
        for word in words:
            node = root
            for ch in word:
                node = node.children.setdefault(ch, TrieNode())
            node.word = word
        rows, cols = len(board), len(board[0])
        res = []
        def dfs(row, col, node):
            ch = board[row][col]
            if ch not in node.children:
                return
            nxt = node.children[ch]
            if nxt.word:
                res.append(nxt.word)
                nxt.word = None
            board[row][col] = '#'
            for di, dj in [(1,0),(-1,0),(0,1),(0,-1)]:
                ni, nj = row + di, col + dj
                if 0 <= ni < rows and 0 <= nj < cols and board[ni][nj] != '#':
                    dfs(ni, nj, nxt)
            board[row][col] = ch
            if not nxt.children:
                node.children.pop(ch, None)
        for row in range(rows):
            for col in range(cols):
                dfs(row, col, root)
        return res
```

## 高级数据结构

### 146 LRU 缓存
题目：设计 LRU 缓存，支持 get/put，超出容量时淘汰最近最少使用项。
示例：输入：capacity = 2, put(1,1), put(2,2), get(1), put(3,3)；输出：get(1)=1，key 2 被淘汰
思路：哈希 + 双向链表。

```python
class Node:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.cap = capacity
        self.mp = {}
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head

    def _remove(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def _add(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    def get(self, key: int) -> int:
        if key not in self.mp:
            return -1
        node = self.mp[key]
        self._remove(node)
        self._add(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key in self.mp:
            node = self.mp[key]
            node.value = value
            self._remove(node)
            self._add(node)
            return
        if len(self.mp) == self.cap:
            lru = self.tail.prev
            self._remove(lru)
            self.mp.pop(lru.key, None)
        node = Node(key, value)
        self.mp[key] = node
        self._add(node)
```

### 460 LFU 缓存
题目：设计 LFU 缓存，按最少使用频次淘汰；频次相同则淘汰最久未使用项。
示例：输入：capacity = 2, put(1,1), put(2,2), get(1), put(3,3)；输出：key 2 被淘汰
思路：双哈希 + 频次链表。

```python
from collections import defaultdict

class Node:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.freq = 1

class LFUCache:
    def __init__(self, capacity: int):
        self.cap = capacity
        self.minf = 0
        self.nodes = {}
        self.freqs = defaultdict(dict)

    def _touch(self, node: Node):
        freq = node.freq
        self.freqs[freq].pop(node.key, None)
        if not self.freqs[freq] and self.minf == freq:
            self.minf += 1
        node.freq += 1
        self.freqs[node.freq][node.key] = node

    def get(self, key: int) -> int:
        if key not in self.nodes:
            return -1
        node = self.nodes[key]
        self._touch(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if self.cap == 0:
            return
        if key in self.nodes:
            node = self.nodes[key]
            node.value = value
            self._touch(node)
            return
        if len(self.nodes) == self.cap:
            key, _ = next(iter(self.freqs[self.minf].items()))
            self.freqs[self.minf].pop(key, None)
            self.nodes.pop(key, None)
        node = Node(key, value)
        self.nodes[key] = node
        self.freqs[1][key] = node
        self.minf = 1
```
